:projectid: kubernetes-caching-hazelcast-spring
:page-layout: guide
:page-duration: 15 minutes
:page-releasedate: 2019-06-20
:page-description: Explore how to use caching in microservices within Kubernetes environment.
:page-tags: ['Hazelcast', 'Caching', 'Microservices', 'Kubernetes', 'Containers','Spring Boot' , 'Minikube']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes-intro']
:source-highlighter: prettify
:page-seo-title: Caching in microservices with Hazelcast Tutorial
:page-seo-description: How to use Hazelcast with microservices
= Caching Microservices with Hazelcast in Kubernetes

Use Hazelcast Caching in Spring Boot based Microservices and deploy to Kubernetes

:minikube-ip: 192.168.99.100
:kube: Kubernetes
:hashtag: #
:win: WINDOWS
:mac: MAC
:linux: LINUX
:hazelcast: Hazelcast

// =================================================================================================
// What you'll learn
// =================================================================================================

== What you'll learn

You will learn how to use Hazelcast distributed caching with Spring Boot and deploy to a local {kube} cluster.
You will then create a Kubernetes Service which load balance between containers and verify that you can share data between Microservices.

The microservice you will deploy is called `hazelcast-spring`. The `hazelcast-spring` microservice simply
helps you put a data and read it back. As Kubernetes Service will send the request to different pod each time 
you initiate the request, the data will be served by shared hazelcast cluster between `hazelcast-spring` pods.

You will use a local single-node {kube} cluster. However, you can deploy this application on any kubernetes distributions.

== What is {hazelcast}?
Hazelcast is an open source In-Memory Data Grid (IMDG). It provides elastically scalable distributed In-Memory computing, 
widely recognized as the fastest and most scalable approach to application performance.

Hazelcast is designed to scale up to hundreds and thousands of members. 
Simply add new members and they will automatically discover the cluster 
and will linearly increase both memory and processing capacity

== Why Spring Boot?

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".
To learn more about Spring Boot. 
http://spring.io/projects/spring-boot

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

Before you begin, have the following tools installed:


First, you will need a containerization software for building containers. {kube} supports a variety
 of container types. You will use `Docker` in this guide. For installation instructions, refer to the https://docs.docker.com/install/[official Docker documentation^].

****
[system]#*{win} | {mac}*#

Use Docker Desktop, where a local {kube} environment is pre-installed and enabled. If you do not see the {kube} tab then you have an older version of Docker Desktop; upgrade to the latest version.

Complete the setup for your operating system:

 - Set up  https://docs.docker.com/docker-for-windows/#kubernetes[Docker for Windows^]. 
 On the Docker for Windows _General Setting_ page, ensure that the option `Expose daemon on 
 tcp://localhost:2375 without TLS` is enabled. This is required by the `dockerfile-maven` 
 part of the build.
 - Set up https://docs.docker.com/docker-for-mac/#kubernetes[Docker for Mac^].

- After following one of the sets of instructions, ensure that {kube} (not Swarm) is selected as the orchestrator in Docker Preferences.

[system]#*{linux}*#

You will use `Minikube` as a single-node {kube} cluster that runs locally in a virtual machine.
For Minikube installation instructions see the https://github.com/kubernetes/minikube#installation[minikube installation instructions^]. Make sure to pay attention to the requirements as they vary by platform.

You will also need Maven to build the jar file. For Maven installation instructions see the https://maven.apache.org/install.html[maven installation instructions^].

****

== Getting started

The fastest way to work through this guide is to clone the Git repository and use the projects that are provided inside:

[subs="attributes"]
----
git clone https://github.com/enozcan/guide-kubernetes-caching-hazelcast-spring.git
cd guide-{projectid}
----

The `initial` directory contains the starting project that you will build upon.

The `final` directory contains the finished project that you will build.


== Running Spring Application 

The application in initial directory is a basic SpringBoot app having 3 endpoints:

- "/" is the homepage returning "Welcome" string only
- "/put" is the page where key and values can be put on a concurrent hash map.
- "/get" is the page where the values in the map can be obtained by keys.

Build the app using Maven in the `initial` directory:

----
$ > mvn package
----

Run the application:
----
$ > java -jar target/hazelcast-spring-app-0.1.0.jar
----


Now your app is runnning on localhost:8080. You can test by following requests:

----
$ > curl localhost:8080
$ > curl localhost:8080/put?key=key1&value=hazelcast
$ > curl localhost:8080/get?key=key1
----

This part was an introduction of the applicaiton. You can stop your application by CTRL + C.

== Dockerizing the App

To create the docker image of the application, add following line into pom.xml file.
----
Under properties:

<docker.image.prefix>springio</docker.image.prefix>
----
----
Under plugins:

<plugin>
    <groupId>com.spotify</groupId>
    <artifactId>dockerfile-maven-plugin</artifactId>
    <version>1.4.9</version>
    <configuration>
        <repository>${docker.image.prefix}/${project.artifactId}</repository>
    </configuration>
</plugin>
----

Then create the Dockerfile under `initial` directory named "Dockerfile" containing the instructions for creatinf docker image:

----
Dockerfile

FROM openjdk:8-jdk-alpine

VOLUME /tmp

ARG JAR_FILE=target/hazelcast-spring-app-0.1.0.jar

ADD ${JAR_FILE} hazelcast-spring-demo.jar

ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/hazelcast-spring-demo.jar"]
----

To create the Docker image of the app, first rebuild the app:
----
mvn clean package
----
Then create image file:
----
docker build -t hazelcast-spring-demo .
----

Now, the image must be seen among the docker images:
----
docker images

<ss goes here>
----

== Running the app in container

Now that the Docker image is ready, check if the image runs properly:

----
docker run -p 5000:8080 hazelcast-spring-demo 
----

Test the app on the port 5000:
----
curl localhost:5000
curl localhost:5000/put?key=key1&value=hazelcast
curl localhost:5000/get?key=key1
----

If you see the same responses as the ones you get when the app is run without container, that means it's all OK with the image.

To stop the container, get the container ID first:
----
docker ps
----
Then find the application's container ID and stop the container:
----
docker stop [CONTAINER-ID]
----


== Starting and preparing your cluster for deployment

Now that you have a proper docker image, deploy the app to kuberntes pods. Start your {kube} cluster first.

****
[system]#*{win} | {mac}*#

Start your Docker Desktop environment. Make sure "Docker Desktop is running" and "Kubernetes is running" status are updated. 

ifdef::docker-desktop-description[]
{docker-desktop-description}
endif::[]

[system]#*{linux}*#

Run the following command from a command line:

[subs="attributes"]
```
ifdef::minikube-start[]
{minikube-start}
endif::[]
ifndef::minikube-start[]
minikube start
endif::[]
```

ifdef::minikube-description[]
{minikube-description}
endif::[]
****   

=== Validate {kube} environment

Next, validate that you have a healthy {kube} environment by running the following command from the command line.

```
kubectl get nodes
```

This command should return a `Ready` status for the master node.

****
[system]#*{win} | {mac}*#

You do not need to do any other step.

[system]#*{linux}*#

Run the following command to configure the Docker CLI to use Minikube's Docker daemon.
After you run this command, you will be able to interact with Minikube's Docker daemon and build new
images directly to it from your host machine:

```
eval $(minikube docker-env)
```
****


After you're sure that a master node is ready, create kubernetes.yaml under `initial` directory with the same content in the `final/kubernetes.yaml` file.

This file defines two {kube} resources: one statefulset and one service. 
StatefulSet is preferred solution for Hazelcast because it enables controlled scale out/in of your microservices 
for easy data distribution. To learn more about StatefulSet, you can visit Kubernetes documentation
https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/

By default, we create 2 replicas of `hazelcast-spring` microservice behind the `hazelcast-spring-service` which forwards
requests to one of the pods available in the kubernetes cluster.

`MY_POD_NAME` is an environment variable made available to the pods so that each microservice knows which pod they are in.
This is going to be used in this guide in order to show which pod is responding to the http request.

Run the following command to deploy the resources as defined in kubernetes.yaml:
----
kubectl apply -f kubernetes.yaml
----
Run the following command to check the status of your pods:
----
kubectl get pods
----

You'll see an output similar to the following if all the pods are healthy and running:
----
<output here>
----

Send request to port :31000 and see the pods responding.
----
curl localhost:31000

<output here>
----

And add a value to the map and then get the value:
----

> curl localhost:31000/put?key=key1&value=hazelcast

	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --> the second pod's response

> curl localhost:31000/get?key=key1

	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --> the second pod's response
	{"value":null,"podName":"hazelcast-spring-statefulset-0"} --> the first pod's response
----

As can be seen, data is not shared between nodes. Here is where Hazelcast comes into action.
Kill active pods under `initial` directory by:
----
kubectl delete -f kubernetes.yaml
----

== Hazelcast Caching among Kubernetes pods

Now we will use Hazelcast Caching among the pods. Update the pom.xml file by adding those dependencies:
----
<dependency>
            <groupId>com.hazelcast</groupId>
            <artifactId>hazelcast</artifactId>
            <version>3.11.2</version>
</dependency>
<dependency>
            <groupId>com.hazelcast</groupId>
            <artifactId>hazelcast-kubernetes</artifactId>
            <version>1.3.1</version>
</dependency>
----
Then modify the CommandController.java such that Hazelcast is used in the map. Also add Hazelcast config to Application.java file and hazelcast libraries as well. 
Those versions are the ones under `final` folder.

Rebuild the app and create new image:

----
mvn clean package
docker build -t hazelcast-spring-demo .
----

Before deploying on kubernetes, create rbac.yaml file as in the `final` directory. Role Based Access Controller(RBAC) configuration is used to give access to Kubernetes Master API from pods which runs microservices. Hazelcast requires a read access to autodiscover other hazelcast members and form hazelcast cluster.

Run the following commands to deploy the resources as defined in kubernetes.yaml and rbac.yaml in the specified order:
----
kubectl apply -f rbac.yaml
----
----
kubectl apply -f kubernetes.yaml
----

Run the following command to check the status of your pods:
----
kubectl get pods
----

You should also check if hazelcast cluster is formed by checking one of the pod’s log file:
----
kubectl logs hazelcast-caching-statefulset-1
----
You must see such a response at the end of the log:
----
Members {size:2, ver:2} [
	Member [172.17.0.4]:5701 - 71009ef7-ee18-45f0-8a8f-e9321931e9ce this
	Member [172.17.0.5]:5701 - 99222e16-93e5-4453-ac9e-cdf3e80069c6
]
----

Now we expect all nodes to give the same value for the same key put on the map via one pod only. Let's try:

----
> curl "http://localhost:31000/put?key=key1&value=hazelcast"

	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --> pod1 responsed

> curl "http://localhost:31000/get?key=key1"

	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --> pod1 responsed

> curl "http://localhost:31000/get?key=key1"

	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-0"} --> pod0 responsed
----

As can be seen, the insertion is made on hazelcast-spring-statefulset-1 but both nodes gives the same value for the key now.

== Scaling with Hazelcast

Scale the cluster with one more pod and see that you still retrieve the shared data.

[role='command']
```
kubectl scale statefulset hazelcast-caching-statefulset --replicas=3
```

Run following command to see the latest status of the pods
[role='command']
```
kubectl get pods
```

As you can see, a new pod `hazelcast-caching-statefulset-2` has joined to the cluster.
[source, role="no_copy"]
----
NAME                              READY     STATUS    RESTARTS   AGE
hazelcast-caching-statefulset-0   1/1       Running   0          8m
hazelcast-caching-statefulset-1   1/1       Running   0          8m
hazelcast-caching-statefulset-2   1/1       Running   0          31s
----

Run the following command again to see the output
[role='command']
```
while true; do curl http://localhost:31000/get?key=1;echo; sleep 2; done
```

As you can see, `hazelcast-caching-statefulset-2` is returning correct data.

[source, role="no_copy"]
----
{"value":"hazelcast_springboot_openliberty","podName":"hazelcast-caching-statefulset-1"}
{"value":"hazelcast_springboot_openliberty","podName":"hazelcast-caching-statefulset-2"}
{"value":"hazelcast_springboot_openliberty","podName":"hazelcast-caching-statefulset-0"}
----

== Testing microservices that are running on {kube}

Create a testing class under `final/src/test/java/it/io/spring/guides/hazelcast/`
named `HazelcastCachingIT.java` .The contents of the test file is available under `finish` directoy.

Also change the pom.xml file for the tests:
----
Under spring-boot-maven-plugin:

<!-- test executions -->
<executions>
        <execution>
            <id>pre-integration-test</id>
            <goals>
                <goal>start</goal>
            </goals>
            <configuration>
                <skip>true</skip>
            </configuration>
        </execution>
        <execution>
            <id>post-integration-test</id>
            <goals>
                <goal>stop</goal>
            </goals>
            <configuration>
                <skip>true</skip>
            </configuration>
        </execution>
</executions>

----

----
Under dependencies:


<dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
</dependency>

----

The test makes sure that the /put endpoint is handled by one pod and /get methods returns the same data from the other kubernetes pod.

It first puts a key/value pair to hazelcast-caching microservice and keeps podname in the firstpod variable. In the second part, tests submits multiple /get requests until to see that podname is different then the pod which initially handled /put request.

In order to run integration tests, you must have a running hazelcast-caching microservices in minikube environment. As you have gone through all previous steps, you already have it.

navigate back to `initial` directory and run following:

----
mvn verify
----
Once you get the success message, start the test you've just created:
----
mvn -Dtest=HazelcastCachingIT test 
----


If the tests pass, you’ll see a similar output to the following:

----
< output here >
----


== Tearing down the environment

When you no longer need your deployed microservices, you can delete all Kubernetes resources by running the kubectl delete command: You might need to wait up to 30 seconds as stateful sets kills pods one at a time.

----
kubectl delete -f kubernetes.yaml
----

****
[system]#*{win} | {mac}*#

Nothing more needs to be done for Docker Desktop.

[system]#*{linux}*#

Perform the following steps to return your environment to a clean state.

. Point the Docker daemon back to your local machine:
+
```
eval $(minikube docker-env -u)
```

. Stop your Minikube cluster:
+
```
minikube stop
```

. Delete your cluster:
+
```
minikube delete
```

****

== Great work! You’re done!

You have just run a Spring Boot application and created its Docker image. First you runned the app on a container and then deployed it to Kubernetes. You then added Hazelcast caching to the hazelcast-spring, tested with a simple curl command. You also scaled out the microservices and saw that data is shared between microservices. As a last step, you ran integration tests against hazelcast-spring that was deployed in a Kubernetes cluster.
